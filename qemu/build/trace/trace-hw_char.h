/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_PARALLEL_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_PARALLEL_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_READ_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_WRITE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RECEIVE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_RESET_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_REALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_UNREALIZE_EVENT;
extern TraceEvent _TRACE_GOLDFISH_TTY_INSTANCE_INIT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_ESCC_HARD_RESET_EVENT;
extern TraceEvent _TRACE_ESCC_SOFT_RESET_CHN_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_FULL_EVENT;
extern TraceEvent _TRACE_PL011_BAUDRATE_CHANGE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_SET_PARAMS_EVENT;
extern TraceEvent _TRACE_NRF51_UART_READ_EVENT;
extern TraceEvent _TRACE_NRF51_UART_WRITE_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_READ_EVENT;
extern TraceEvent _TRACE_SHAKTI_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMABUSY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMAREADY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_INTCLR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RO_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WO_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RXSIZE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_CHANNEL_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_TIMEOUT_EVENT;
extern TraceEvent _TRACE_CADENCE_UART_BAUDRATE_EVENT;
extern uint16_t _TRACE_PARALLEL_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_PARALLEL_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_READ_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_WRITE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RECEIVE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_RESET_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_REALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_UNREALIZE_DSTATE;
extern uint16_t _TRACE_GOLDFISH_TTY_INSTANCE_INIT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_ESCC_HARD_RESET_DSTATE;
extern uint16_t _TRACE_ESCC_SOFT_RESET_CHN_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_FULL_DSTATE;
extern uint16_t _TRACE_PL011_BAUDRATE_CHANGE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_SET_PARAMS_DSTATE;
extern uint16_t _TRACE_NRF51_UART_READ_DSTATE;
extern uint16_t _TRACE_NRF51_UART_WRITE_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_READ_DSTATE;
extern uint16_t _TRACE_SHAKTI_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMABUSY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMAREADY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_INTCLR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RO_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WO_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RXSIZE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_CHANNEL_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_TIMEOUT_DSTATE;
extern uint16_t _TRACE_CADENCE_UART_BAUDRATE_DSTATE;
#define TRACE_PARALLEL_IOPORT_READ_ENABLED 1
#define TRACE_PARALLEL_IOPORT_WRITE_ENABLED 1
#define TRACE_SERIAL_READ_ENABLED 1
#define TRACE_SERIAL_WRITE_ENABLED 1
#define TRACE_SERIAL_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GOLDFISH_TTY_READ_ENABLED 1
#define TRACE_GOLDFISH_TTY_WRITE_ENABLED 1
#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RECEIVE_ENABLED 1
#define TRACE_GOLDFISH_TTY_RESET_ENABLED 1
#define TRACE_GOLDFISH_TTY_REALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_UNREALIZE_ENABLED 1
#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_ESCC_HARD_RESET_ENABLED 1
#define TRACE_ESCC_SOFT_RESET_CHN_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_PUT_FIFO_ENABLED 1
#define TRACE_PL011_PUT_FIFO_FULL_ENABLED 1
#define TRACE_PL011_BAUDRATE_CHANGE_ENABLED 1
#define TRACE_CMSDK_APB_UART_READ_ENABLED 1
#define TRACE_CMSDK_APB_UART_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_UART_RESET_ENABLED 1
#define TRACE_CMSDK_APB_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_PENDING_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_ENABLED 1
#define TRACE_CMSDK_APB_UART_SET_PARAMS_ENABLED 1
#define TRACE_NRF51_UART_READ_ENABLED 1
#define TRACE_NRF51_UART_WRITE_ENABLED 1
#define TRACE_SHAKTI_UART_READ_ENABLED 1
#define TRACE_SHAKTI_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_DMABUSY_ENABLED 1
#define TRACE_EXYNOS_UART_DMAREADY_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_RAISED_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_LOWERED_ENABLED 1
#define TRACE_EXYNOS_UART_UPDATE_PARAMS_ENABLED 1
#define TRACE_EXYNOS_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_ENABLED 1
#define TRACE_EXYNOS_UART_INTCLR_ENABLED 1
#define TRACE_EXYNOS_UART_RO_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_WO_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RXSIZE_ENABLED 1
#define TRACE_EXYNOS_UART_CHANNEL_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_RX_TIMEOUT_ENABLED 1
#define TRACE_CADENCE_UART_BAUDRATE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_PARALLEL_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 256 "trace/trace-hw_char.h"
        } else {
#line 4 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 260 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_read(desc, addr, value);
    }
}

#define TRACE_PARALLEL_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 287 "trace/trace-hw_char.h"
        } else {
#line 5 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 291 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_write(desc, addr, value);
    }
}

#define TRACE_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_serial_read(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_read " "read addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 318 "trace/trace-hw_char.h"
        } else {
#line 8 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("serial_read " "read addr 0x%02x val 0x%02x" "\n", addr, value);
#line 322 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_read(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_read(addr, value);
    }
}

#define TRACE_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_serial_write(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_write " "write addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 349 "trace/trace-hw_char.h"
        } else {
#line 9 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("serial_write " "write addr 0x%02x val 0x%02x" "\n", addr, value);
#line 353 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_write(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_write(addr, value);
    }
}

#define TRACE_SERIAL_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_SERIAL_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, parity, data_bits, stop_bits);
#line 380 "trace/trace-hw_char.h"
        } else {
#line 10 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n", baudrate, parity, data_bits, stop_bits);
#line 384 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_serial_update_parameters(baudrate, parity, data_bits, stop_bits);
    }
}

#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event, value);
#line 411 "trace/trace-hw_char.h"
        } else {
#line 13 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_send_control_event " "port %u, event %u, value %u" "\n", port, event, value);
#line 415 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_send_control_event(port, event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, throttle);
#line 442 "trace/trace-hw_char.h"
        } else {
#line 14 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_throttle_port " "port %u, throttle %d" "\n", port, throttle);
#line 446 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        _nocheck__trace_virtio_serial_throttle_port(port, throttle);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event, value);
#line 473 "trace/trace-hw_char.h"
        } else {
#line 15 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message " "event %u, value %u" "\n", event, value);
#line 477 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message(event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message_port " "port %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port);
#line 504 "trace/trace-hw_char.h"
        } else {
#line 16 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message_port " "port %u" "\n", port);
#line 508 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message_port(port);
    }
}

#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) || \
    false)

static inline void _nocheck__trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, len, ret);
#line 535 "trace/trace-hw_char.h"
        } else {
#line 19 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n", port, len, ret);
#line 539 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        _nocheck__trace_virtio_console_flush_buf(port, len, ret);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_READ) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_read " "port %u, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, size);
#line 566 "trace/trace-hw_char.h"
        } else {
#line 20 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_console_chr_read " "port %u, size %d" "\n", port, size);
#line 570 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_read(port, size);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_event " "port %u, event %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event);
#line 597 "trace/trace-hw_char.h"
        } else {
#line 21 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("virtio_console_chr_event " "port %u, event %d" "\n", port, event);
#line 601 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_event(port, event);
    }
}

#define TRACE_GOLDFISH_TTY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_READ) || \
    false)

static inline void _nocheck__trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 628 "trace/trace-hw_char.h"
        } else {
#line 24 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_read " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 632 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_read(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_read(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_WRITE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, size, value);
#line 659 "trace/trace-hw_char.h"
        } else {
#line 25 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_write " "tty: %p reg: 0x%02x size: %d value: 0x%"PRIx64 "\n", dev, addr, size, value);
#line 663 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_write(void * dev, unsigned int addr, unsigned int size, uint64_t value)
{
    if (true) {
        _nocheck__trace_goldfish_tty_write(dev, addr, size, value);
    }
}

#define TRACE_GOLDFISH_TTY_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_can_receive " "tty: %p available: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, available);
#line 690 "trace/trace-hw_char.h"
        } else {
#line 26 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_can_receive " "tty: %p available: %u" "\n", dev, available);
#line 694 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_can_receive(void * dev, unsigned int available)
{
    if (true) {
        _nocheck__trace_goldfish_tty_can_receive(dev, available);
    }
}

#define TRACE_GOLDFISH_TTY_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RECEIVE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_receive " "tty: %p size: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, size);
#line 721 "trace/trace-hw_char.h"
        } else {
#line 27 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_receive " "tty: %p size: %u" "\n", dev, size);
#line 725 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_receive(void * dev, unsigned int size)
{
    if (true) {
        _nocheck__trace_goldfish_tty_receive(dev, size);
    }
}

#define TRACE_GOLDFISH_TTY_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_RESET) || \
    false)

static inline void _nocheck__trace_goldfish_tty_reset(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_reset " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 752 "trace/trace-hw_char.h"
        } else {
#line 28 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_reset " "tty: %p" "\n", dev);
#line 756 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_reset(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_reset(dev);
    }
}

#define TRACE_GOLDFISH_TTY_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_REALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_realize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_realize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 783 "trace/trace-hw_char.h"
        } else {
#line 29 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_realize " "tty: %p" "\n", dev);
#line 787 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_realize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_realize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_UNREALIZE) || \
    false)

static inline void _nocheck__trace_goldfish_tty_unrealize(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_unrealize " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 814 "trace/trace-hw_char.h"
        } else {
#line 30 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_unrealize " "tty: %p" "\n", dev);
#line 818 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_unrealize(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_unrealize(dev);
    }
}

#define TRACE_GOLDFISH_TTY_INSTANCE_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GOLDFISH_TTY_INSTANCE_INIT) || \
    false)

static inline void _nocheck__trace_goldfish_tty_instance_init(void * dev)
{
    if (trace_event_get_state(TRACE_GOLDFISH_TTY_INSTANCE_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:goldfish_tty_instance_init " "tty: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 845 "trace/trace-hw_char.h"
        } else {
#line 31 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("goldfish_tty_instance_init " "tty: %p" "\n", dev);
#line 849 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_goldfish_tty_instance_init(void * dev)
{
    if (true) {
        _nocheck__trace_goldfish_tty_instance_init(dev);
    }
}

#define TRACE_GRLIB_APBUART_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_EVENT) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_event(int event)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_event " "event:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event);
#line 876 "trace/trace-hw_char.h"
        } else {
#line 34 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_event " "event:%d" "\n", event);
#line 880 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_event(event);
    }
}

#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 907 "trace/trace-hw_char.h"
        } else {
#line 35 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n", addr, value);
#line 911 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_writel_unknown(addr, value);
    }
}

#define TRACE_GRLIB_APBUART_READL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_READL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 938 "trace/trace-hw_char.h"
        } else {
#line 36 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n", addr);
#line 942 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_readl_unknown(addr);
    }
}

#define TRACE_ESCC_HARD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_HARD_RESET) || \
    false)

static inline void _nocheck__trace_escc_hard_reset(void)
{
    if (trace_event_get_state(TRACE_ESCC_HARD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_hard_reset " "hard reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 969 "trace/trace-hw_char.h"
        } else {
#line 39 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_hard_reset " "hard reset" "\n");
#line 973 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_hard_reset(void)
{
    if (true) {
        _nocheck__trace_escc_hard_reset();
    }
}

#define TRACE_ESCC_SOFT_RESET_CHN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SOFT_RESET_CHN) || \
    false)

static inline void _nocheck__trace_escc_soft_reset_chn(char channel)
{
    if (trace_event_get_state(TRACE_ESCC_SOFT_RESET_CHN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_soft_reset_chn " "soft reset channel %c" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 1000 "trace/trace-hw_char.h"
        } else {
#line 40 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_soft_reset_chn " "soft reset channel %c" "\n", channel);
#line 1004 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_soft_reset_chn(char channel)
{
    if (true) {
        _nocheck__trace_escc_soft_reset_chn(channel);
    }
}

#define TRACE_ESCC_PUT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_PUT_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_put_queue(char channel, int b)
{
    if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_put_queue " "channel %c put: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, b);
#line 1031 "trace/trace-hw_char.h"
        } else {
#line 41 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_put_queue " "channel %c put: 0x%02x" "\n", channel, b);
#line 1035 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        _nocheck__trace_escc_put_queue(channel, b);
    }
}

#define TRACE_ESCC_GET_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_GET_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_get_queue(char channel, int val)
{
    if (trace_event_get_state(TRACE_ESCC_GET_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_get_queue " "channel %c get 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1062 "trace/trace-hw_char.h"
        } else {
#line 42 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_get_queue " "channel %c get 0x%02x" "\n", channel, val);
#line 1066 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        _nocheck__trace_escc_get_queue(channel, val);
    }
}

#define TRACE_ESCC_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_escc_update_irq(int irq)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_irq " "IRQ = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq);
#line 1093 "trace/trace-hw_char.h"
        } else {
#line 43 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_update_irq " "IRQ = %d" "\n", irq);
#line 1097 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        _nocheck__trace_escc_update_irq(irq);
    }
}

#define TRACE_ESCC_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data_bits, stop_bits);
#line 1124 "trace/trace-hw_char.h"
        } else {
#line 44 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n", channel, speed, parity, data_bits, stop_bits);
#line 1128 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_escc_update_parameters(channel, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_ESCC_MEM_WRITEB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1155 "trace/trace-hw_char.h"
        } else {
#line 45 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1159 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_WRITEB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1186 "trace/trace-hw_char.h"
        } else {
#line 46 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_mem_writeb_data " "Write channel %c, ch %d" "\n", channel, val);
#line 1190 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_data(channel, val);
    }
}

#define TRACE_ESCC_MEM_READB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1217 "trace/trace-hw_char.h"
        } else {
#line 47 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1221 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_READB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ret);
#line 1248 "trace/trace-hw_char.h"
        } else {
#line 48 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_mem_readb_data " "Read channel %c, ch %d" "\n", channel, ret);
#line 1252 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_data(channel, ret);
    }
}

#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SERIAL_RECEIVE_BYTE) || \
    false)

static inline void _nocheck__trace_escc_serial_receive_byte(char channel, int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 1279 "trace/trace-hw_char.h"
        } else {
#line 49 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_serial_receive_byte " "channel %c put ch %d" "\n", channel, ch);
#line 1283 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        _nocheck__trace_escc_serial_receive_byte(channel, ch);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_IN) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch, name, down);
#line 1310 "trace/trace-hw_char.h"
        } else {
#line 50 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n", ch, name, down);
#line 1314 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_in(ch, name, down);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_OUT) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_out(int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 1341 "trace/trace-hw_char.h"
        } else {
#line 51 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n", ch);
#line 1345 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_out(ch);
    }
}

#define TRACE_ESCC_KBD_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_KBD_COMMAND) || \
    false)

static inline void _nocheck__trace_escc_kbd_command(int val)
{
    if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_kbd_command " "Command %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1372 "trace/trace-hw_char.h"
        } else {
#line 52 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_kbd_command " "Command %d" "\n", val);
#line 1376 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        _nocheck__trace_escc_kbd_command(val);
    }
}

#define TRACE_ESCC_SUNMOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNMOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dx, dy, buttons_state);
#line 1403 "trace/trace-hw_char.h"
        } else {
#line 53 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n", dx, dy, buttons_state);
#line 1407 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        _nocheck__trace_escc_sunmouse_event(dx, dy, buttons_state);
    }
}

#define TRACE_PL011_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_pl011_irq_state(int level)
{
    if (trace_event_get_state(TRACE_PL011_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 1434 "trace/trace-hw_char.h"
        } else {
#line 56 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_irq_state " "irq state %d" "\n", level);
#line 1438 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        _nocheck__trace_pl011_irq_state(level);
    }
}

#define TRACE_PL011_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ) || \
    false)

static inline void _nocheck__trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1465 "trace/trace-hw_char.h"
        } else {
#line 57 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_read " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 1469 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_read(addr, value);
    }
}

#define TRACE_PL011_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_read_fifo(int read_count)
{
    if (trace_event_get_state(TRACE_PL011_READ_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read_fifo " "FIFO read, read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , read_count);
#line 1496 "trace/trace-hw_char.h"
        } else {
#line 58 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_read_fifo " "FIFO read, read_count now %d" "\n", read_count);
#line 1500 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read_fifo(int read_count)
{
    if (true) {
        _nocheck__trace_pl011_read_fifo(read_count);
    }
}

#define TRACE_PL011_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_WRITE) || \
    false)

static inline void _nocheck__trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_write " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1527 "trace/trace-hw_char.h"
        } else {
#line 59 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_write " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 1531 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_write(addr, value);
    }
}

#define TRACE_PL011_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lcr, read_count, r);
#line 1558 "trace/trace-hw_char.h"
        } else {
#line 60 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n", lcr, read_count, r);
#line 1562 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (true) {
        _nocheck__trace_pl011_can_receive(lcr, read_count, r);
    }
}

#define TRACE_PL011_PUT_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo " "new char 0x%x read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c, read_count);
#line 1589 "trace/trace-hw_char.h"
        } else {
#line 61 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_put_fifo " "new char 0x%x read_count now %d" "\n", c, read_count);
#line 1593 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo(c, read_count);
    }
}

#define TRACE_PL011_PUT_FIFO_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO_FULL) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo_full(void)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo_full " "FIFO now full, RXFF set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1620 "trace/trace-hw_char.h"
        } else {
#line 62 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_put_fifo_full " "FIFO now full, RXFF set" "\n");
#line 1624 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo_full(void)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo_full();
    }
}

#define TRACE_PL011_BAUDRATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_BAUDRATE_CHANGE) || \
    false)

static inline void _nocheck__trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (trace_event_get_state(TRACE_PL011_BAUDRATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, clock, ibrd, fbrd);
#line 1651 "trace/trace-hw_char.h"
        } else {
#line 63 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n", baudrate, clock, ibrd, fbrd);
#line 1655 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (true) {
        _nocheck__trace_pl011_baudrate_change(baudrate, clock, ibrd, fbrd);
    }
}

#define TRACE_CMSDK_APB_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1682 "trace/trace-hw_char.h"
        } else {
#line 66 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1686 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1713 "trace/trace-hw_char.h"
        } else {
#line 67 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1717 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1744 "trace/trace-hw_char.h"
        } else {
#line 68 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n");
#line 1748 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_reset();
    }
}

#define TRACE_CMSDK_APB_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1775 "trace/trace-hw_char.h"
        } else {
#line 69 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n", c);
#line 1779 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_receive(c);
    }
}

#define TRACE_CMSDK_APB_UART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1806 "trace/trace-hw_char.h"
        } else {
#line 70 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n");
#line 1810 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx_pending();
    }
}

#define TRACE_CMSDK_APB_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1837 "trace/trace-hw_char.h"
        } else {
#line 71 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n", c);
#line 1841 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx(c);
    }
}

#define TRACE_CMSDK_APB_UART_SET_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_SET_PARAMS) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_set_params(int speed)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_SET_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed);
#line 1868 "trace/trace-hw_char.h"
        } else {
#line 72 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n", speed);
#line 1872 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_set_params(int speed)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_set_params(speed);
    }
}

#define TRACE_NRF51_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_READ) || \
    false)

static inline void _nocheck__trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 1899 "trace/trace-hw_char.h"
        } else {
#line 75 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, r, size);
#line 1903 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_read(addr, r, size);
    }
}

#define TRACE_NRF51_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_WRITE) || \
    false)

static inline void _nocheck__trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1930 "trace/trace-hw_char.h"
        } else {
#line 76 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 1934 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_write(addr, value, size);
    }
}

#define TRACE_SHAKTI_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_READ) || \
    false)

static inline void _nocheck__trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 1961 "trace/trace-hw_char.h"
        } else {
#line 79 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("shakti_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx16 " size %u" "\n", addr, r, size);
#line 1965 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_read(uint64_t addr, uint16_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_read(addr, r, size);
    }
}

#define TRACE_SHAKTI_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SHAKTI_UART_WRITE) || \
    false)

static inline void _nocheck__trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_SHAKTI_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1992 "trace/trace-hw_char.h"
        } else {
#line 80 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("shakti_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 1996 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_shakti_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_shakti_uart_write(addr, value, size);
    }
}

#define TRACE_EXYNOS_UART_DMABUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMABUSY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMABUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2023 "trace/trace-hw_char.h"
        } else {
#line 83 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n", channel);
#line 2027 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmabusy(channel);
    }
}

#define TRACE_EXYNOS_UART_DMAREADY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMAREADY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmaready(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMAREADY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmaready " "UART%d: DMA ready" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2054 "trace/trace-hw_char.h"
        } else {
#line 84 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_dmaready " "UART%d: DMA ready" "\n", channel);
#line 2058 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmaready(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmaready(channel);
    }
}

#define TRACE_EXYNOS_UART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2085 "trace/trace-hw_char.h"
        } else {
#line 85 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n", channel, reg);
#line 2089 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_raised(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2116 "trace/trace-hw_char.h"
        } else {
#line 86 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n", channel);
#line 2120 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_lowered(channel);
    }
}

#define TRACE_EXYNOS_UART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data, stop, wordtime);
#line 2147 "trace/trace-hw_char.h"
        } else {
#line 87 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n", channel, speed, parity, data, stop, wordtime);
#line 2151 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (true) {
        _nocheck__trace_exynos_uart_update_params(channel, speed, parity, data, stop, wordtime);
    }
}

#define TRACE_EXYNOS_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2178 "trace/trace-hw_char.h"
        } else {
#line 88 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2182 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_write(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2209 "trace/trace-hw_char.h"
        } else {
#line 89 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2213 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_read(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_RX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2240 "trace/trace-hw_char.h"
        } else {
#line 90 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n", channel);
#line 2244 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2271 "trace/trace-hw_char.h"
        } else {
#line 91 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n", channel);
#line 2275 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2302 "trace/trace-hw_char.h"
        } else {
#line 92 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n", channel, ch);
#line 2306 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_INTCLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_INTCLR) || \
    false)

static inline void _nocheck__trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_INTCLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2333 "trace/trace-hw_char.h"
        } else {
#line 93 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n", channel, reg);
#line 2337 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_intclr(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_RO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RO_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2364 "trace/trace-hw_char.h"
        } else {
#line 94 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2368 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_ro_write(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2395 "trace/trace-hw_char.h"
        } else {
#line 95 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n", channel, ch);
#line 2399 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_RX_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_error " "UART%d: Rx error" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2426 "trace/trace-hw_char.h"
        } else {
#line 96 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_error " "UART%d: Rx error" "\n", channel);
#line 2430 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_error(channel);
    }
}

#define TRACE_EXYNOS_UART_WO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WO_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2457 "trace/trace-hw_char.h"
        } else {
#line 97 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2461 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_wo_read(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RXSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RXSIZE) || \
    false)

static inline void _nocheck__trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RXSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, size);
#line 2488 "trace/trace-hw_char.h"
        } else {
#line 98 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n", channel, size);
#line 2492 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (true) {
        _nocheck__trace_exynos_uart_rxsize(channel, size);
    }
}

#define TRACE_EXYNOS_UART_CHANNEL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_CHANNEL_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_channel_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_CHANNEL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_channel_error " "Wrong UART channel number: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2519 "trace/trace-hw_char.h"
        } else {
#line 99 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_channel_error " "Wrong UART channel number: %d" "\n", channel);
#line 2523 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_channel_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_channel_error(channel);
    }
}

#define TRACE_EXYNOS_UART_RX_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_TIMEOUT) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, stat, intsp);
#line 2550 "trace/trace-hw_char.h"
        } else {
#line 100 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n", channel, stat, intsp);
#line 2554 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_timeout(channel, stat, intsp);
    }
}

#define TRACE_CADENCE_UART_BAUDRATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CADENCE_UART_BAUDRATE) || \
    false)

static inline void _nocheck__trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (trace_event_get_state(TRACE_CADENCE_UART_BAUDRATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cadence_uart_baudrate " "baudrate %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate);
#line 2581 "trace/trace-hw_char.h"
        } else {
#line 103 "/home/anna/AMDSEV/qemu/hw/char/trace-events"
            qemu_log("cadence_uart_baudrate " "baudrate %u" "\n", baudrate);
#line 2585 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (true) {
        _nocheck__trace_cadence_uart_baudrate(baudrate);
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
